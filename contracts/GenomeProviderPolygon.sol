// SPDX-License-Identifier: MIT
// Roach Racing Club: the first strategic p2e game with deflationary mechanisms (https://roachracingclub.com/)
pragma solidity ^0.8.10;

import "../interfaces/IRoachNFT.sol";
import "./Operators.sol";


/// @title Genome generator
/// @author Shadow Syndicate / Andrey Pelipenko (kindex@kindex.lv)
/// @dev Should be deployed on cheap network, like Polygon
///      TokenSeed is generated using formula sha3(sha3(devSeed, tokenId, traitBonus), vrfSeed)
///      Where:
///        tokenId - roach id.
///        traitBonus - trait bonus from whitelist, 0 for public sale.
///        vrfSeed - random value that is generated by Chainlink VRF after sha3(devSeed) is published.
///        devSeed - secret value, that is available only to developer team while genesis sale is not finished.
///      TokenSeed is unpredictable during the mint stage for all parties:
///        Developers can't predict vrfSeed and mintBlockHash
///        Miners can't predict devSeed
///        Buyers can't predict devSeed and vrfSeed
///      So TokenSeed is unpredictable but fixed and can be checked at any time after the reveal.
///      Genome is generated using tokenSeed. For the same tokenSeed, there will be equal genomes.
///      After the genesis sale is finished, the game will publish devSeed, and anyone will be able to
///      check tokenSeeds and corresponding genomes.
///      Genome is signed by the secret private key and transferred from Polygon network to Ethereum
///      as part of the reveal process.
/// @dev GenomeProviderPolygon is used only for testing because of mocked VRF request.
///      GenomeProviderChainlink should be used for production.
contract GenomeProviderPolygon is Operators {

    uint constant TRAIT_COUNT = 6;
    uint constant MAX_BONUS = 25;

    struct TraitConfig {
        uint32 sum;
        uint8[] slots;
        // data format: trait1, color1a, color1b, trait2, color2a, color2b, ...
        uint8[] traitData;
        uint16[] weight;
        uint16[] weightMaxBonus;
    }

    mapping(uint => TraitConfig) public traits; // slot -> array of trait weight

    struct Roach {
        uint vrfSeed;
        uint mix;
        uint tokenSeed;
        uint8 traitBonus;
        uint64 revealTime;
        bytes genome;
    }

    mapping(uint => Roach) public roach;

    uint256 public devSeedHash;
    uint256 public devSeed;

    event DevSeedHash(uint256 devSeedHash);
    event DevSeed(uint256 devSeedHash);
    event Reveal(uint tokenId, uint mix, uint vrfSeed, uint tokenSeed, bytes genome);

    constructor(uint256 _devSeedHash) {
        devSeedHash = _devSeedHash;
        emit DevSeedHash(devSeedHash);
    }

    function publishDevSeed(uint _devSeed) external onlyOwner {
        devSeed = _devSeed;
        emit DevSeed(devSeed);
    }

    function isRevealed(uint tokenId) external view returns (bool) {
        return roach[tokenId].revealTime != 0;
    }

    function getRoach(uint tokenId) external view returns (Roach memory) {
        return roach[tokenId];
    }

    function calculateMix(uint tokenId, uint traitBonus, uint devSeed)
        public view returns (bytes32 mix)
    {
        return keccak256(abi.encodePacked(tokenId, traitBonus, devSeed));
    }

    /// @dev Function is used to check tokenSeed generation after devSeed is published
    function calculateTokenSeed(uint tokenId, uint traitBonus, uint devSeed, uint vrfSeed)
        external view returns (uint tokenSeed)
    {
        uint mix = uint(calculateMix(tokenId, traitBonus, devSeed));
        return uint(keccak256(abi.encodePacked(mix, vrfSeed)));
    }

    function calculateTokenSeedFromMix(uint mix, uint vrfSeed)
        public view returns (uint token_seed)
    {
        return uint(keccak256(abi.encodePacked(mix, vrfSeed)));
    }

    /// @dev Calculates genome for each roach using tokenSeed as seed
    function calculateGenome(uint256 tokenSeed, uint8 traitBonus) external view returns (bytes memory genome) {
        genome = _normalizeGenome(tokenSeed, traitBonus);
    }

    /// @dev Called only after contract is deployed and before genomes are generated
    // TODO: add owner sig
    function requestReveal(uint tokenId, uint mix, uint8 traitBonus) external onlyOperator {
        require(roach[tokenId].mix == 0, "Can't call twice");
        roach[tokenId].mix = mix;
        roach[tokenId].traitBonus = traitBonus;
        _requestRandomness(tokenId);
    }

    /// @dev Stub function for filling random, will be overriden in Chainlink version
    function _requestRandomness(uint tokenId) internal virtual {
        uint256 randomness = uint(keccak256(abi.encodePacked(block.timestamp)));
        _onRandomnessArrived(tokenId, randomness);
    }

    /// @dev Saves Chainlink VRF random value as vrfSeed
    function _onRandomnessArrived(uint tokenId, uint256 _randomness) internal {
        doReveal(tokenId, _randomness);
    }

    function doReveal(uint tokenId, uint256 vrfSeed) internal {
        Roach storage _roach = roach[tokenId];
        require(_roach.vrfSeed == 0, "Can't call twice");
        _roach.vrfSeed = vrfSeed;
        _roach.tokenSeed = calculateTokenSeedFromMix(_roach.mix, _roach.vrfSeed);
        _roach.genome = _normalizeGenome(_roach.tokenSeed, _roach.traitBonus);
        _roach.revealTime = uint64(block.timestamp);
        emit Reveal(tokenId, _roach.mix, _roach.vrfSeed, _roach.tokenSeed, _roach.genome);
    }

    /// @dev Setups genome configuration
    function setTraitConfig(
        uint traitIndex,
        uint8[] calldata _slots,
        uint8[] calldata _traitData,
        uint16[] calldata _weight,
        uint16[] calldata _weightMaxBonus
    )
        external onlyOperator
    {
        require(_weight.length == _weightMaxBonus.length, 'weight length mismatch');
        require(_slots.length * _weight.length == _traitData.length, '_traitData length mismatch');

        uint32 sum = 0;
        for (uint i = 0; i < _weight.length; i++) {
            sum += _weight[i];
        }
        traits[traitIndex] = TraitConfig(sum, _slots, _traitData, _weight, _weightMaxBonus);
    }

    function getWeightedRandom(uint traitType, uint randomSeed, uint bonus)
        internal view
        returns (uint choice, uint newRandomSeed)
    {
        TraitConfig storage config = traits[traitType];
        uint div = config.sum * MAX_BONUS;
        uint r = randomSeed % div;
        uint i = 0;
        uint acc = 0;
        while (true) {
            acc += config.weight[i] * (MAX_BONUS - bonus) + (config.weightMaxBonus[i] * bonus);
            if (acc > r) {
                choice = i;
                newRandomSeed = randomSeed / div;
                break;
            }
            i++;
        }
    }

    function _normalizeGenome(uint256 _randomness, uint8 _traitBonus) internal view returns (bytes memory) {

        bytes memory result = new bytes(32);
        result[0] = 0; // version
        for (uint i = 1; i <= TRAIT_COUNT; i++) {
            uint trait;
            (trait, _randomness) = getWeightedRandom(i, _randomness, _traitBonus);
            TraitConfig storage config = traits[i];
            for (uint j = 0; j < config.slots.length; j++) {
                result[config.slots[j]] = bytes1(uint8(config.traitData[trait * config.slots.length + j]));
            }
        }

        TraitConfig storage lastConfig = traits[TRAIT_COUNT];
        uint maxSlot = lastConfig.slots[lastConfig.slots.length - 1];
        for (uint i = maxSlot + 1; i < 32; i++) {
            result[i] = bytes1(uint8(_randomness & 0xFF));
            _randomness >>= 8;
        }
        return result;
    }
}
