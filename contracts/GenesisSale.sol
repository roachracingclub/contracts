// SPDX-License-Identifier: MIT
// Roach Racing Club: the first strategic p2e game with deflationary mechanisms (https://roachracingclub.com/)
pragma solidity ^0.8.10;

import "./Operators.sol";
import "../interfaces/IRoachNFT.sol";

/// @title Genesis collection sale contract
/// @author Shadow Syndicate / Andrey Pelipenko (kindex@kindex.lv)
/// @dev Sell 10k tokens with fixed price in two stages
/// @dev Stage 1: Whitelisted presale with limit by account
/// @dev Stage 2: Public sale without limit
contract GenesisSale is Operators {

    uint public ROACH_PRICE;
    uint public TOTAL_TOKENS_ON_SALE = 10_000;
    uint public STAGE1_START;
    uint public STAGE1_DURATION;
    address public signerAddress;
    IRoachNFT public roachContract;

    event Purchase(address indexed account, uint count, uint traitBonus, string syndicate);

    constructor(
        IRoachNFT _roachContract,
        uint stage1startTime,
        uint stage1durationSeconds,
        uint price,
        uint totalTokensOnSale)
    {
        roachContract = _roachContract;
        STAGE1_START = stage1startTime;
        STAGE1_DURATION = stage1durationSeconds;
        ROACH_PRICE = price;
        TOTAL_TOKENS_ON_SALE = totalTokensOnSale;
        signerAddress = msg.sender;
    }

    /// @notice Returns current sale status
    /// @param account Selected buyer address
    /// @return stage One of number 0..3: 0 - presale not started. 1 - Presale. 2 - Public sale. 3 - sale is over.
    /// @return leftToMint Left roaches to mint in total
    /// @return nextStageTimestamp UNIX time of current stage finish and next stage start. Always 0 for for stages 2 and 3.
    /// @return price One roach price in ETH.
    /// @return allowedToMint For stage 2 - max count for one tx.
    function getSaleStatus(address account, uint limitForAccount) external view returns (
        uint stage,
        int leftToMint,
        uint nextStageTimestamp,
        uint price,
        int allowedToMint)
    {
        stage = getSaleStage();

        price = ROACH_PRICE;
        nextStageTimestamp =
            stage == 0 ? STAGE1_START :
            stage == 1 ? STAGE1_START + STAGE1_DURATION :
            0;
        leftToMint = int(TOTAL_TOKENS_ON_SALE) - int(totalMinted());
        allowedToMint =
            stage == 1 ? (int)(getAllowedToBuyForAccountOnPresale(account, limitForAccount)) :
            stage == 2 ? leftToMint :
            int(0);
    }

    /// @notice Total number of minted tokens
    function totalMinted() public view returns (uint256) {
        return roachContract.lastRoachId();
    }

    function isPresaleActive() public view returns (bool) {
        return STAGE1_START <= block.timestamp
            && block.timestamp < STAGE1_START + STAGE1_DURATION
            && totalMinted() < TOTAL_TOKENS_ON_SALE;
    }

    function isSaleStage2Active() public view returns (bool) {
        return STAGE1_START + STAGE1_DURATION <= block.timestamp
            && totalMinted() < TOTAL_TOKENS_ON_SALE;
    }

    /// @return stage One of number 0..3: 0 - presale not started. 1 - Presale. 2 - Public sale. 3 - sale is over.
    function getSaleStage() public view returns (uint) {
        return isPresaleActive() ? 1 :
            isSaleStage2Active() ? 2 :
            block.timestamp < STAGE1_START ? 0 :
            3;
    }

    /// @notice Takes payment and mints new roaches on Presale Sale.
    /// @dev    Function checks signature, generated by backend for buyer account according to whitelist limitations.
    ///         Can be called twice if total minted token count doesn't exceed limitForAccount.
    /// @param desiredCount The number of roach to mint
    /// @param limitForAccount Original buy limit from whitelist
    /// @param traitBonus Trait bonus from whitelist (12 means 12% bonus)
    /// @param syndicate (Optional) Syndicate name, that player wants join to. Selected syndicate will receive a bonus.
    /// @param sigV sigR sigS Signature that can be generated only by secret key, stored on game backend
    function mintStage1(
        uint desiredCount,
        uint limitForAccount,
        uint8 traitBonus,
        string calldata syndicate,
        uint8 sigV,
        bytes32 sigR,
        bytes32 sigS
    )
        external payable
    {
        require(isValidSignature(msg.sender, limitForAccount, traitBonus, sigV, sigR, sigS), "Wrong signature");
        _mintStage1(msg.sender, desiredCount, limitForAccount, traitBonus, syndicate);
    }

    /// @notice returns left allowed tokens for minting on Presale if purchase is preformed using several transaction
    function getAllowedToBuyForAccountOnPresale(address account, uint limitForAccount) public view returns (uint) {
        uint256 numberMinted = roachContract.getNumberMinted(account);
        return limitForAccount > numberMinted
            ? limitForAccount - numberMinted
            : 0;
    }

    function _mintStage1(address account, uint desiredCount, uint limitForAccount, uint8 traitBonus, string calldata syndicate) internal {
        uint stage = getSaleStage();
        require(stage == 1, "Presale not active");
        uint leftToMint = getAllowedToBuyForAccountOnPresale(account, limitForAccount);
        require(desiredCount <= leftToMint, 'Account limit reached');

        _buy(account, desiredCount, syndicate, traitBonus);
    }

    /// @notice Takes payment and mints new roaches on Public Sale
    /// @param desiredCount The number of roaches to mint
    /// @param syndicate (Optional) Syndicate name, that player wants join to. Selected syndicate will receive a bonus.
    function mintStage2(uint desiredCount, string calldata syndicate) external payable {
        uint stage = getSaleStage();
        require(stage == 2, "Public sale not active");
        _buy(msg.sender, desiredCount, syndicate, 0);
    }

    function _buy(address account, uint count, string calldata syndicate, uint8 traitBonus) internal {
        require(count > 0, 'Min count is 1');
        uint soldCount = totalMinted();
        if (soldCount + count > TOTAL_TOKENS_ON_SALE) {
            count = TOTAL_TOKENS_ON_SALE - soldCount; // allow to buy left tokens
        }
        uint needMoney = ROACH_PRICE * count;
        emit Purchase(account, count, traitBonus, syndicate);
        _mintRaw(account, count, traitBonus, syndicate);
        _acceptMoney(needMoney);
    }

    function _acceptMoney(uint needMoney) internal {
        require(msg.value >= needMoney, "Insufficient money");
        if (msg.value > needMoney) {
            payable(msg.sender).transfer(msg.value - needMoney);
        }
    }

    function _mintRaw(address to, uint count, uint8 traitBonus, string calldata syndicate) internal {
        roachContract.mintGen0(to, count, traitBonus, syndicate);
    }

    /// Signatures

    /// @notice Internal function used in signature checking
    function hashArguments(address account, uint limitForAccount, uint8 traitBonus)
        public pure returns (bytes32 msgHash)
    {
        msgHash = keccak256(abi.encode(account, limitForAccount, traitBonus));
    }

    /// @notice Internal function used in signature checking
    function getSigner(
        address account, uint limitForAccount, uint8 traitBonus,
        uint8 sigV, bytes32 sigR, bytes32 sigS
    )
        public pure returns (address)
    {
        bytes32 msgHash = hashArguments(account, limitForAccount, traitBonus);
        return ecrecover(msgHash, sigV, sigR, sigS);
    }

    /// @notice Internal function used in signature checking
    function isValidSignature(
        address account, uint limitForAccount, uint8 traitBonus,
        uint8 sigV, bytes32 sigR, bytes32 sigS
    )
        public
        view
        returns (bool)
    {
        return getSigner(account, limitForAccount, traitBonus, sigV, sigR, sigS) == signerAddress;
    }

    /// @notice Mints new NFT with selected parameters
    /// @dev There is a guarantee that there will no more than 10k genesis roaches
    function mintOperator(address to, uint count, uint8 traitBonus, string calldata syndicate) external onlyOperator {
        uint soldCount = totalMinted();
        require(soldCount + count <= TOTAL_TOKENS_ON_SALE, "Sale is over");
        _mintRaw(to, count, traitBonus, syndicate);
    }

    /// @notice Changes secret key that is used for signature generation
    function setSigner(address newSigner) external onlyOwner {
        signerAddress = newSigner;
    }

}
